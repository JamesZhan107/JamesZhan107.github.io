<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>James&#39;s Blog</title>
  
  <subtitle>Winter is coming, Hope is everything!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jameszhan.cf/"/>
  <updated>2019-01-23T15:18:12.847Z</updated>
  <id>http://jameszhan.cf/</id>
  
  <author>
    <name>詹姆斯·文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSM学习系列（二）：SpringMVC概述</title>
    <link href="http://jameszhan.cf/2019/01/23/SSM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ASpringMVC%E6%A6%82%E8%BF%B0/"/>
    <id>http://jameszhan.cf/2019/01/23/SSM学习系列（二）：SpringMVC概述/</id>
    <published>2019-01-23T14:20:50.000Z</published>
    <updated>2019-01-23T15:18:12.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h1><blockquote><p>SpringMVC属于表现层的框架，它是Spring框架的一部分。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2018121810540278.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181218105646726.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="SpringMVC实现过程详解"><a href="#SpringMVC实现过程详解" class="headerlink" title="SpringMVC实现过程详解"></a>SpringMVC实现过程详解</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181218112943313.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>浏览器提交请求到中央调度器</li><li>中央调度器直接将请求转给处理器映射器。</li><li>处理器映射器会根据请求，找到处理该请求的处理器，并将其封装为处理器执行链后返回给中央调度器。</li><li>中央调度器根据处理器执行链中的处理器，找到能够执行该处理器的处理器适配器。</li><li>处理器适配器调用执行处理器。</li><li>处理器将处理结果及要跳转的视图封装到一个对象ModelAndView中，并将其返回给 处理器适配器。</li><li>处理器适配器直接将结果返回给中央调度器。</li><li>中央调度器调用视图解析器，将ModelAndView中的视图名称封装为视图对象。</li></ol><h1 id="SpringMVC开发流程"><a href="#SpringMVC开发流程" class="headerlink" title="SpringMVC开发流程"></a>SpringMVC开发流程</h1><h2 id="导入Jar包"><a href="#导入Jar包" class="headerlink" title="导入Jar包"></a>导入Jar包</h2><h2 id="注册中央调度器"><a href="#注册中央调度器" class="headerlink" title="注册中央调度器"></a>注册中央调度器</h2><p><img src="https://img-blog.csdnimg.cn/20181218111150322.png" alt=""></p><h2 id="创建SpringMVC配置文件"><a href="#创建SpringMVC配置文件" class="headerlink" title="创建SpringMVC配置文件"></a>创建SpringMVC配置文件</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181219210111708.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="定义处理器"><a href="#定义处理器" class="headerlink" title="定义处理器"></a>定义处理器</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181218112833217.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>ModelAndView类中的addObject()方法用于向其Model中添加数据，因为该函数的返回值为ModelAndView，所以可以向Model中连续添加多个数据。</p><h2 id="注册处理器"><a href="#注册处理器" class="headerlink" title="注册处理器"></a>注册处理器</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181218112307584.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在springmvc.xml中注册处理器。需要注意的是处理器的id属性值为一个请求URI，表示当客户端提交该请求时，会访问class指定的这个处理器。</p><h2 id="配置试图解析器"><a href="#配置试图解析器" class="headerlink" title="配置试图解析器"></a>配置试图解析器</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2018121811274758.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>SpringMVC框架为了避免对于请求资源路径与扩展名的冗余，在视图解析器InternalResouceViewResolver中引入了请求的前缀和后缀。</p><h2 id="定义目标页面"><a href="#定义目标页面" class="headerlink" title="定义目标页面"></a>定义目标页面</h2><p>编写前端页面代码</p><h1 id="URL路径问题"><a href="#URL路径问题" class="headerlink" title="URL路径问题"></a>URL路径问题</h1><h2 id="访问路径与资源路径"><a href="#访问路径与资源路径" class="headerlink" title="访问路径与资源路径"></a>访问路径与资源路径</h2><blockquote><p>通常的URL资源访问路径由两部分构成：访问路径与资源名称。</p></blockquote><p>访问路径，则是通过该路径则可以定位到指定的资源，即在URL资源访问路径中除了资 源名称以外的其它部分。一般情况下，在URL访问路径中，最后一部分为资源名称，而其它部分则为访问路径。</p><p>资源名称指的是要访问资源的直接名称，如show.jsp，或与要访问资源存在映射关系的间接名称，如show.do。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181218144447508.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181218144506578.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h2><blockquote><p>根据“访问路径是否可以独立完成资源准确定位”的评判标准，可以将访问路径分为绝对路径和相对路径。</p></blockquote><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><blockquote><p>绝对路径是指根据给出的访问路径可以准确定位到资源的路径，对于计算机中Web应用的绝对路径则是指带访问协议的路径。如：<a href="http://127.0.0.1:8080/primary/index.jsp" target="_blank" rel="noopener">http://127.0.0.1:8080/primary/index.jsp</a></p></blockquote><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><blockquote><p>相对路径是指根据给出的访问路径无法准确定位到资源的路径，相对路径必须要结合其参照路径才可以组成可以准确定位资源的绝对路径。</p></blockquote><p>在Web应用中，相对路径的写法有两种：一种是以斜杠开头的相对路径，一种是不以 斜杠开头的相对路径。根据相对路径是否以斜杠开头，且出现的文件所处位置的不同，其默认的参照路径是不同的，这也是相对路径容易出错的地方：确定参照路径！</p><h4 id="以斜杠开头的相对路径"><a href="#以斜杠开头的相对路径" class="headerlink" title="以斜杠开头的相对路径"></a>以斜杠开头的相对路径</h4><h5 id="前台路径"><a href="#前台路径" class="headerlink" title="前台路径"></a>前台路径</h5><p>所谓前台路径是指，由浏览器解析执行的代码中所包含的路径。例如，html、css、js中的路径，及jsp中静态部分的路径。像html及jsp中的静态部分中的img src=” “、href=” “、form action=” “等；像 css 中的 background:img(“ “}等；像 window.location.href=” “，都属于前台路径。<br>前台路径的参照路径是Web服务器的根路径，即：<a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a></p><h5 id="后台路径"><a href="#后台路径" class="headerlink" title="后台路径"></a>后台路径</h5><p>所谓后台路径是指，由服务器解析执行的代码及文件中所包含的路径。例如，java代码中的路径、jsp文件动态部分（java代码块）中的路径、xml文件中的路径（xml文件是要被 java代码加载入内存，并由java代码解析的）等。<br>后台路径的参照路径是Web应用的根路径。如：<a href="http://127.0.0.1:8080/primary/" target="_blank" rel="noopener">http://127.0.0.1:8080/primary/</a></p><h5 id="后台路径特例"><a href="#后台路径特例" class="headerlink" title="后台路径特例"></a>后台路径特例</h5><p>对于后台路径的参照路径有一个特例：当代码中使用 response 的 sendRedirect()方法进行重定向时，其参照路径不是web应用的路径，而是web服务器的根路径。<br>例如，执行response.sendRedirect(“/show.jsp”)将会报404错误。因为其参照路径是 Tomcat的根，而非当前项目的根。所以若要使用重定向，要么写为无斜杠的相对路径，要么在路径上添加项目名称。</p><h4 id="不以斜杠开头的相对路径"><a href="#不以斜杠开头的相对路径" class="headerlink" title="不以斜杠开头的相对路径"></a>不以斜杠开头的相对路径</h4><p>不以斜杠开头的相对路径，无论是前台路径，还是后台路径，其参照路径都是当前资源的访问路径，而不是当前资源的保存路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC简介&quot;&gt;&lt;a href=&quot;#SpringMVC简介&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC简介&quot;&gt;&lt;/a&gt;SpringMVC简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;SpringMVC属于表现层的框架，它是S
      
    
    </summary>
    
      <category term="后端技术" scheme="http://jameszhan.cf/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://jameszhan.cf/tags/Java/"/>
    
      <category term="SSM" scheme="http://jameszhan.cf/tags/SSM/"/>
    
      <category term="SpringMVC" scheme="http://jameszhan.cf/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SSM学习系列（一）：前言</title>
    <link href="http://jameszhan.cf/2019/01/22/SSM%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%89%8D%E8%A8%80/"/>
    <id>http://jameszhan.cf/2019/01/22/SSM学习系列（一）：前言/</id>
    <published>2019-01-22T10:58:40.000Z</published>
    <updated>2019-01-23T14:41:22.132Z</updated>
    
    <content type="html"><![CDATA[<p>SSM是Spring、SpringMVC、Mybatis的简称，是现在常用的java web开发框架之一。本学习系列是笔者在学习北京动力节点教学资料后的笔记与总结。</p><p>第一讲前言，主要内容概括起来就是一种系统架构，两个常用工具，三例设计模式。</p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><blockquote><p>Java Web都遵循三层架构原则；三层架构中的视图层使用MVC结构；Spring是管理和实现三层架构的一种技术框架；SpringMVC是一种实现视图层的特殊MVC；MyBatis是一种实现持久层的方式。</p></blockquote><h2 id="Java三层架构"><a href="#Java三层架构" class="headerlink" title="Java三层架构"></a>Java三层架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181125172432792.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181125172526996.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="三层架构与MVC"><a href="#三层架构与MVC" class="headerlink" title="三层架构与MVC"></a>三层架构与MVC</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181125172654297.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="SSM与三层架构"><a href="#SSM与三层架构" class="headerlink" title="SSM与三层架构"></a>SSM与三层架构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181125172735454.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="JUint测试"><a href="#JUint测试" class="headerlink" title="JUint测试"></a>JUint测试</h1><blockquote><p>JUnit测试是一种方便且高效的测试工具。</p></blockquote><p>完成测试的步骤</p><ol><li>下载Jar包并在工程中导入。  </li><li>创建测试类：有两种方式，一种是使用IDE向导自动创建；一种是使用注解手动创建。  </li><li>使用@Before @After @Test注解，编写相应函数 </li></ol><h1 id="Log4j日志"><a href="#Log4j日志" class="headerlink" title="Log4j日志"></a>Log4j日志</h1><blockquote><p>Log4j与Log4j2是Apache公司开发的日志记录工具。日志信息根据用途与记录内容的不同，分为调试日志、运行日志、异常日志等，日志记录对软件的开发十分有用。</p></blockquote><p>日志级别分为：fatal、error、warn、info、debug、trace</p><p>日志输出控制文件的主要构成：输出位置、输出级别、输出格式</p><p>完成日志记录的步骤</p><ol><li>导入Jar包  </li><li>放入日志输出控制文件  </li><li>代码中实现日志记录：在需要输出日志的类中创建日志对象logger，并通过logger的方法在代码中加入日志输出语句。如：logger.debug(“this is debug message”)</li></ol><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote><p>代理模式的出现是因为某些情况下一个对象不适合或不能被另一个对象引用 ，于是会提供一种代理以控制对对象的访问，就好比打官司的时候，当事人会请代理律师。即代理就是委托其他类做自己不擅长或者不想直接参与的事情。  </p><p>律师分为法律顾问和普通律师，代理也分为静态代理和动态代理，区别就在于代理关系建立的时间。</p></blockquote><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><blockquote><p>即法律顾问，在官司产生前，即程序运行前便确定好的。需要自己定义代理类，并要与目标类实现相同的业务接口。</p></blockquote><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote><p>即普通律师，在官司产生后，即在程序运行时确定的。</p></blockquote><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>通过java.lang.reflect.Proxy类实现代理，使用其newProxyInstance()方法。主业务逻辑增强类需要实现接口InvocationHandler，并且重写invoke()方法，增强逻辑的代码就写在该方法中。<br>使用JDK的Proxy实现代理，要求目标类与代理类实现相同的接口。若目标类不存在接口，则无法使用该方式实现。</p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>对于无接口的目标类，就需要使用CGLIB实现，但条件是目标类必须能被继承，不能是final类。<br>通过代理生成工厂类实现，该类需要实现MethodInterceptor接口。在类中需要做三件事：（1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。（2）定义代理的生成方法，用来创建代理对象，其中需要创建一个增强器Enhancer并设置回调setCallBack()。（3）定义回调接口方法，对目标类的增强就在这里完成。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><blockquote><p>适配器模式就是某些类的接口转换为可以统一管理的接口.目的在于使没有办法一起工作的类一起工作，方便管理。类比于将不同工作的人统一组织起来，一起工作，便于统一管理。</p></blockquote><h2 id="不使用适配器"><a href="#不使用适配器" class="headerlink" title="不使用适配器"></a>不使用适配器</h2><p>调用各个类时，只能分别调用。<br><img src="https://img-blog.csdnimg.cn/2018112622052457.png" alt=""></p><h2 id="单适配器模式"><a href="#单适配器模式" class="headerlink" title="单适配器模式"></a>单适配器模式</h2><p>只有一个适配器接口，当调用类时，需要用适配器接口进行匹配。<br><img src="https://img-blog.csdnimg.cn/20181126220625725.png" alt=""></p><h2 id="多适配器模式"><a href="#多适配器模式" class="headerlink" title="多适配器模式"></a>多适配器模式</h2><p>用总的适配器接口去匹配各个类的适配器，实现统一管理。<br><img src="https://img-blog.csdnimg.cn/20181126220746750.png" alt=""></p><h2 id="缺省适配器模式"><a href="#缺省适配器模式" class="headerlink" title="缺省适配器模式"></a>缺省适配器模式</h2><p>当Targer目标角色有很多方法，那么每个适配器都要去实现接口中这些方法，这样做太麻烦。于是可以首先实现一个默认适配器，然后实际的实现目标角色接口类去继承这个默认适配器，然后重写默认实现的方法即可。<br><img src="https://img-blog.csdnimg.cn/20181126222026544.png" width="400" height="380" alt="图片名称"></p><h1 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h1><blockquote><p>某些类的实现可能会需要几个固定步骤。而对于该类的不同对象，有些步骤的实现是固定不变的，有些是完全不同的，有些是可变可不变的，于是就会用到模板方法设计模式。节省代码量。</p><p>好比在完成网络购物的时候，登录是每个用户都必须要做的，选择物品是每个用户都不一样的，选择付款时只有固定的几种，默认支付宝，但也可以使用银行卡支付。这便是模板方法设计模式。</p></blockquote><h2 id="模板方法的构成"><a href="#模板方法的构成" class="headerlink" title="模板方法的构成"></a>模板方法的构成</h2><p><img src="https://img-blog.csdnimg.cn/20181127141552438.png" width="400" height="400" alt="图片名称"></p><h2 id="模板方法的实现"><a href="#模板方法的实现" class="headerlink" title="模板方法的实现"></a>模板方法的实现</h2><p>一个父类，包含模板方法和步骤方法；<br>若干子类，继承父类，并重写抽象方法和选择性重写钩子方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SSM是Spring、SpringMVC、Mybatis的简称，是现在常用的java web开发框架之一。本学习系列是笔者在学习北京动力节点教学资料后的笔记与总结。&lt;/p&gt;
&lt;p&gt;第一讲前言，主要内容概括起来就是一种系统架构，两个常用工具，三例设计模式。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="后端技术" scheme="http://jameszhan.cf/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://jameszhan.cf/tags/Java/"/>
    
      <category term="SSM" scheme="http://jameszhan.cf/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Java web架构介绍</title>
    <link href="http://jameszhan.cf/2019/01/21/Java-web%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jameszhan.cf/2019/01/21/Java-web架构介绍/</id>
    <published>2019-01-21T13:40:57.000Z</published>
    <updated>2019-01-23T14:42:00.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常规的J2EE三层架构"><a href="#常规的J2EE三层架构" class="headerlink" title="常规的J2EE三层架构"></a>常规的J2EE三层架构</h1><p><img src="https://img-blog.csdnimg.cn/20181108110835831.png" width="600" height="400"></p><h1 id="Alibaba提倡的分层结构"><a href="#Alibaba提倡的分层结构" class="headerlink" title="Alibaba提倡的分层结构"></a>Alibaba提倡的分层结构</h1><p><img src="https://img-blog.csdnimg.cn/20181108110624498.jpg" width="600" height="400"></p><h2 id="Web-层"><a href="#Web-层" class="headerlink" title="Web 层"></a>Web 层</h2><p>主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</p><h2 id="Service-层"><a href="#Service-层" class="headerlink" title="Service 层"></a>Service 层</h2><p>相对具体的业务逻辑服务层。</p><h2 id="Manager-层"><a href="#Manager-层" class="headerlink" title="Manager 层"></a>Manager 层</h2><p>通用业务处理层，它有如下特征： 1） 对第三方平台封装的层，预处理返回结果及转化异常信息； 2） 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理； 3） 与 DAO 层交互，对多个 DAO 的组合复用。</p><h2 id="DAO-层"><a href="#DAO-层" class="headerlink" title="DAO 层"></a>DAO 层</h2><p>数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。</p><h2 id="开放接口层"><a href="#开放接口层" class="headerlink" title="开放接口层"></a>开放接口层</h2><p>可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</p><h2 id="终端显示层"><a href="#终端显示层" class="headerlink" title="终端显示层"></a>终端显示层</h2><p>各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</p><h2 id="外部接口或第三方平台"><a href="#外部接口或第三方平台" class="headerlink" title="外部接口或第三方平台"></a>外部接口或第三方平台</h2><p>包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</p><h1 id="MVC的结构"><a href="#MVC的结构" class="headerlink" title="MVC的结构"></a>MVC的结构</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181108110215665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODUzMjE1OQ==,size_1,color_FFFFFF,t_70" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="SpringMVC的结构及工作原理"><a href="#SpringMVC的结构及工作原理" class="headerlink" title="SpringMVC的结构及工作原理"></a>SpringMVC的结构及工作原理</h1><p><img src="https://img-blog.csdnimg.cn/20181108114234197.png" width="600" height="400"></p><h2 id="工作流程详解"><a href="#工作流程详解" class="headerlink" title="工作流程详解"></a>工作流程详解</h2><ol><li>客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。 </li><li>DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。 </li><li>在这个地方Spring会通过HandlerAdapter对该处理进行封装。 </li><li>HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。 </li><li>Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。 </li><li>ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。 </li><li>当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。 </li><li>客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</li></ol><h2 id="组件及其作用"><a href="#组件及其作用" class="headerlink" title="组件及其作用"></a>组件及其作用</h2><ol><li>前端控制器 (DispatcherServlet)<br>接收请求，响应结果，相当于转发器，中央处理器。负责调用系统的其他模块来真正处理用户的请求。 有了DispatcherServlet减少了其他组件之间的耦合度</li><li>处理器映射器 (HandlerMapping)<br>作用：根据请求的 url 查找 Handler</li><li>处理器 (Handler)<br>注意：编写 Handler 时按照 HandlerAdapter 的要求去做，这样适配器才可以去正确执行 Handler处理器适配器 (HandlerAdapter)<br>作用：按照特定规则（HandlerAdapter要求的规则）执行Handler。</li><li>视图解析器 (ViewResolver)<br>作用：进行视图解析，根据逻辑视图解析成真正的视图 (View)</li><li>视图 (View)<br>View 是一个接口实现类支持不同的 View 类型（jsp,pdf等等）</li></ol><blockquote><p>进行SpringMVC开发时，程序员只需编写处理器和视图。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常规的J2EE三层架构&quot;&gt;&lt;a href=&quot;#常规的J2EE三层架构&quot; class=&quot;headerlink&quot; title=&quot;常规的J2EE三层架构&quot;&gt;&lt;/a&gt;常规的J2EE三层架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg
      
    
    </summary>
    
      <category term="后端技术" scheme="http://jameszhan.cf/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="web" scheme="http://jameszhan.cf/tags/web/"/>
    
      <category term="Java" scheme="http://jameszhan.cf/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="http://jameszhan.cf/2019/01/21/Markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://jameszhan.cf/2019/01/21/Markdown学习笔记/</id>
    <published>2019-01-21T03:43:51.000Z</published>
    <updated>2019-01-21T13:27:43.577Z</updated>
    
    <content type="html"><![CDATA[<p>今天大概学习了一下Markdown的语法，感觉也不是那么难，用起来都比较方便。作为一门编辑类工具，相信是越用越熟，以后多多练习，必能熟练掌握。</p><p>那么就先简单介绍一些常用的语法，之后有需求再去更新。</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>标题有以下六种</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><hr><h1 id="文字格式"><a href="#文字格式" class="headerlink" title="文字格式"></a>文字格式</h1><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><pre><code>**这是文字粗体格式***这是文字斜体格式*&lt;del&gt;在文字上添加删除线 或~~在文字上添加删除线~~`在文字下增加底纹`</code></pre><p><strong>这是文字粗体格式</strong></p><p><em>这是文字斜体格式</em></p><p><del>在文字上添加删除线<br>或<br><del>在文字上添加删除线</del></del></p><p><code>在文字下增加底纹</code></p><hr><h2 id="自定义字体、字号和颜色"><a href="#自定义字体、字号和颜色" class="headerlink" title="自定义字体、字号和颜色"></a>自定义字体、字号和颜色</h2><pre><code>&lt;font color=#0099ff size=6 face=&quot;黑体&quot;&gt;颜色，字号，字体&lt;/font&gt;</code></pre><font color="red" size="6" face="黑体">颜色，字号，字体</font><hr><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><pre><code>[文本内容]（链接地址）</code></pre><p><a href="www.baidu.com">百度一下</a></p><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="原始版"><a href="#原始版" class="headerlink" title="原始版"></a>原始版</h2><p>此种方式无法改变图片的大小</p><pre><code>![图片的描述](图片的链接地址)</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1548079776613&di=30d8bfafe8464ea60d3faae9c83ba992&imgtype=0&src=http%3A%2F%2F06.imgmini.eastday.com%2Fmobile%2F20180609%2F20180609000241_a3be888839a2b04ded0a1e3705c466cf_3.jpeg" alt="最爱的詹姆斯" title="">                </div>                <div class="image-caption">最爱的詹姆斯</div>            </figure><h2 id="升级版"><a href="#升级版" class="headerlink" title="升级版"></a>升级版</h2><p>此种方式可自定义图片大小</p><pre><code>&lt;img src=&quot;./xxx.png&quot; width = &quot;300&quot; height = &quot;200&quot; alt=&quot;图片名称&quot;/&gt;</code></pre><p> <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1548079776613&di=30d8bfafe8464ea60d3faae9c83ba992&imgtype=0&src=http%3A%2F%2F06.imgmini.eastday.com%2Fmobile%2F20180609%2F20180609000241_a3be888839a2b04ded0a1e3705c466cf_3.jpeg" width="300" height="300" alt="最爱的詹姆斯"></p><blockquote><p>如果需要居中的话只要在语句外面包围div标签即可</p></blockquote><pre><code>&lt;div  align=&quot;center&quot;&gt;    ...&lt;/div&gt;</code></pre><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>在文本内容之前加上 &gt;（大于号），即可将文本变成引用文本</p><pre><code>&gt;这是引用部分</code></pre><blockquote><p>这是引用部分</p></blockquote><hr><h1 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h1><p>前面用到了很多代码框，即每个大框都是代码框。有两种办法：1.一对“上三点”包裹代码 2.代码前加四个空格（一个tab键）。两种语法的显示在不同编辑器下可能会有些许区别，前者会有标号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">System.out.println(&quot;这就是代码框&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>public void test(){    System.out.println(&quot;这就是代码框&quot;)}</code></pre><hr><h1 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h1><p>前面也用到了许多分割线，三个小短线即可表示。</p><pre><code>--- 就是这小三只</code></pre><hr><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表项目标记通常放在最左边，项目标记后面要接一个字符的空格</p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>使用星号、加号或是减号作为列表标记</p><pre><code>- 第一- 第二- 第三</code></pre><ul><li>第一</li><li>第二</li><li>第三</li></ul><hr><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>使用数字接着一个英文句点</p><pre><code>1. Red2. Green3. Blue</code></pre><ol><li>Red</li><li>Green</li><li>Blue</li></ol><hr><h2 id="待办列表"><a href="#待办列表" class="headerlink" title="待办列表"></a>待办列表</h2><p>表示列表是否勾选状态（注意：[ ] 前后都要有空格）</p><pre><code>- [ ] 不勾选- [x] 勾选</code></pre><ul><li style="list-style: none"><input type="checkbox"> 不勾选</li><li style="list-style: none"><input type="checkbox" checked> 勾选</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天大概学习了一下Markdown的语法，感觉也不是那么难，用起来都比较方便。作为一门编辑类工具，相信是越用越熟，以后多多练习，必能熟练掌握。&lt;/p&gt;
&lt;p&gt;那么就先简单介绍一些常用的语法，之后有需求再去更新。&lt;/p&gt;
&lt;h1 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; c
      
    
    </summary>
    
      <category term="语言语法" scheme="http://jameszhan.cf/categories/%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Markdown" scheme="http://jameszhan.cf/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>个人博客处女作</title>
    <link href="http://jameszhan.cf/2019/01/19/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%A4%84%E5%A5%B3%E4%BD%9C/"/>
    <id>http://jameszhan.cf/2019/01/19/个人博客处女作/</id>
    <published>2019-01-19T11:14:40.000Z</published>
    <updated>2019-01-19T15:17:44.478Z</updated>
    
    <content type="html"><![CDATA[<p>千呼万唤始出来，james的个人博客终于开通啦！！！</p><p>首先，感谢师兄陈坤大佬的鼎力相助，本博客是完全按照师兄的<a href="https://kchen.cc/2016/11/12/hexo-instructions/" target="_blank" rel="noopener">教程</a>来搭建的，顺便安利一下师兄的<a href="kchen.cc">个人博客</a>。</p><p>接下来说一下自己的几点想法。</p><h3 id="为什么会想着开通个人博客"><a href="#为什么会想着开通个人博客" class="headerlink" title="为什么会想着开通个人博客"></a>为什么会想着开通个人博客</h3><p>说实话，最初想着开个人博客就是单纯地觉得有博客是一个挺牛逼的事，毕竟大佬们都是一有github，二有个人博客，三有微信公众号。正所谓不想当大佬的渣渣不是优秀工程师嘛。</p><p>之后也在CSDN也写过一些技术文章，写着写着就觉得比较局限。首先吧，CSDN的博客页面不是很美丽，影响阅读体验；其次呢，写博客的时候是在它的在线markdown编辑器下进行，用起来不太顺手，而且图片还有水印，让人难以接受；最最重要的是，CSDN它有广告啊，就很烦这一点，明明是单纯的技术分享，阅读的同时页面右侧还有广告随着你的页面移动，令人抓狂。</p><p>前不久恰逢听闻陈坤师兄用极其简单且免费的方法搭建了自己的个人博客，立马就动心了，还没考完《矩阵论》，心里就开始琢磨自己该整一个什么样的。本来以为个人博客得放在自己的服务器上，需要部署还得更新上传，没想到hexo+github如此简单，年轻人要学的还有很多啊！</p><p>还有markdown,自己用的不多，借着个人博客的开通，希望自己能坚持写作，日后慢慢熟悉。</p><h3 id="打算在博客写什么"><a href="#打算在博客写什么" class="headerlink" title="打算在博客写什么"></a>打算在博客写什么</h3><ul><li><p>技术文章。 研究生期间需要自学的东西很多，很多时候学完了如果没有用到的话很快就会遗忘，等某一天需要的时候又得重新学习，所以记录自己的所学很重要。后期我会将CSDN的文章迁移过来。</p></li><li><p>项目总结。 每一次所做的项目，我想都有必要去好好回顾与总结。一方面是对所做项目所花时间有个交代，另外也是对未来的工作有一定的指导意义。</p></li><li><p>随笔。 目前自己的总结和心里记录都是写在自己的有道云笔记里，以后可以考虑迁移到个人博客中来。其次，对于一些社会热点事件，个人小思绪，我也会写在博客中。</p></li></ul><p>自从詹姆斯加盟湖人，紫金便是我最爱的配色。观感尚可，希望大家能多提建议！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;千呼万唤始出来，james的个人博客终于开通啦！！！&lt;/p&gt;
&lt;p&gt;首先，感谢师兄陈坤大佬的鼎力相助，本博客是完全按照师兄的&lt;a href=&quot;https://kchen.cc/2016/11/12/hexo-instructions/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://jameszhan.cf/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
