{"meta":{"title":"James's Blog","subtitle":"Winter is coming, Hope is everything!","description":null,"author":"詹姆斯·文","url":"http://jameszhan.cf"},"pages":[{"title":"categories","date":"2019-01-19T08:40:26.000Z","updated":"2019-01-19T08:40:48.213Z","comments":false,"path":"categories/index.html","permalink":"http://jameszhan.cf/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-19T08:38:41.000Z","updated":"2019-01-19T08:39:50.309Z","comments":true,"path":"tags/index.html","permalink":"http://jameszhan.cf/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spark项目实战（一）：电商用户行为分析大数据平台","slug":"Spark项目实战（一）：电商用户行为分析大数据平台","date":"2019-05-06T14:40:00.000Z","updated":"2019-05-06T14:53:55.833Z","comments":true,"path":"2019/05/06/Spark项目实战（一）：电商用户行为分析大数据平台/","link":"","permalink":"http://jameszhan.cf/2019/05/06/Spark项目实战（一）：电商用户行为分析大数据平台/","excerpt":"","text":"本文主要记录在学习Spark实战项目中的学习进度及简要学习笔记。 Day1用户访问session分析-模块介绍用户访问session分析-基础数据结构以及大数据平台架构介绍用户访问session分析-需求分析用户访问session分析-技术方案设计用户访问session分析-数据表设计Day2","categories":[{"name":"大数据","slug":"大数据","permalink":"http://jameszhan.cf/categories/大数据/"}],"tags":[{"name":"Spark","slug":"Spark","permalink":"http://jameszhan.cf/tags/Spark/"}]},{"title":"","slug":"SparkStreaming + Kafka +Flume","date":"2019-04-07T14:38:31.303Z","updated":"2019-04-07T14:38:31.303Z","comments":true,"path":"2019/04/07/SparkStreaming + Kafka +Flume/","link":"","permalink":"http://jameszhan.cf/2019/04/07/SparkStreaming + Kafka +Flume/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SSM学习系列（五）：SpringMVC核心技术（下）","slug":"SSM学习系列（五）：SpringMVC核心技术（下）","date":"2019-01-25T02:11:32.000Z","updated":"2019-01-25T02:13:59.727Z","comments":true,"path":"2019/01/25/SSM学习系列（五）：SpringMVC核心技术（下）/","link":"","permalink":"http://jameszhan.cf/2019/01/25/SSM学习系列（五）：SpringMVC核心技术（下）/","excerpt":"","text":"数据验证修改 springmvc 配置文件在实体属性上添加验证注解修改 Controller页面显示验证异常信息文件上传上传单个文件上传多个文件拦截器一个拦截器的执行多个拦截器的执行","categories":[{"name":"后端技术","slug":"后端技术","permalink":"http://jameszhan.cf/categories/后端技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jameszhan.cf/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"http://jameszhan.cf/tags/SSM/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://jameszhan.cf/tags/SpringMVC/"}]},{"title":"SSM学习系列（四）：SpringMVC核心技术（上）","slug":"SSM学习系列（四）：SpringMVC核心技术（上）","date":"2019-01-25T01:53:02.000Z","updated":"2019-01-25T02:14:15.063Z","comments":true,"path":"2019/01/25/SSM学习系列（四）：SpringMVC核心技术（上）/","link":"","permalink":"http://jameszhan.cf/2019/01/25/SSM学习系列（四）：SpringMVC核心技术（上）/","excerpt":"","text":"请求转发与重定向返回 ModelAndView 时的请求转发请求转发到页面请求转发到其它 Controller返回 ModelAndView 时的重定向重定向到页面通过 ModelAndView 的 Model 携带参数Step1：修改处理器类 MyControllerStep2：修改 show 页面位置Step3：修改 show 页面内容使用 HttpSession 携带参数重定向到其它 Controller返回 String 时的请求转发返回 String 时的重定向重定向到页面通过 Model 形参携带参数通过形参 RedirectAttributes 的 addAttribute()携带参数重定向到其它 Controller通过 Model 形参携带参数通过形参 RedirectAttributes 的 addFlushAttribute()携带参数返回 void 时的请求转发返回 void 时的重定向异常处理SimpleMappingExceptionResolver 异常处理器实现过程自定义异常类修改 Controller注册异常处理器定义异常响应页面自定义异常处理器实现过程定义异常处理器注册异常处理器异常处理注解实现过程定义异常处理的 Controller修改 Controller类型转换器自定义类型转换器对类型转换器的配置注册类型转换器创建转换服务 Bean使用转换服务 BeanSpringMVC 配置文件总的配置接收多种日期格式的类型转换器数据回显（细节略）自定义类型转换失败后提示信息（细节略）","categories":[{"name":"后端技术","slug":"后端技术","permalink":"http://jameszhan.cf/categories/后端技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jameszhan.cf/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"http://jameszhan.cf/tags/SSM/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://jameszhan.cf/tags/SpringMVC/"}]},{"title":"SSM学习系列（三）：SpringMVC注解式开发","slug":"SSM学习系列（三）：SpringMVC注解式开发","date":"2019-01-24T03:19:48.000Z","updated":"2019-01-25T01:39:24.783Z","comments":true,"path":"2019/01/24/SSM学习系列（三）：SpringMVC注解式开发/","link":"","permalink":"http://jameszhan.cf/2019/01/24/SSM学习系列（三）：SpringMVC注解式开发/","excerpt":"","text":"所谓注解式开发是指，处理器是基于注解的类的开发。对于每一个定义的处理器，无需在配置文件中逐个注册，只需在代码中通过对类与方法的注解，便可完成注册。 注解式开发的实现注册组件扫描器在springmvc.xml中注册。这里的组件指的就是处理器，需要指定处理器所在的基本包。 定义处理器此时的处理器类无需继承任何父类，实现任何接口。只需在类上与方法上添加相应注解即可。@Controller：表示当前类处理器@RequestMapping：表示当前方法为处理器方法，该方法要对value属性所指定的URL进行处理与响应。被注解方法的方法名可以随意。 处理器请求映射规则的定义对请求URI的命名空间的定义一个@Controller所注解的类中，可以定义多个处理器方法。当然，不同的处理器方法所匹配的URI是不同的。这些不同的URI被指定在注解于方法之上的@RequestMapping的 value 属性中。 若这些请求具有相同的URI部分，则这些相同的URI，可以被抽取到注解在类之上的@RequestMapping的value属性中。此时的这个URI称为命名空间。 请求URI中通配符的应用资源名称中使用通配符 在请求的资源名称中使用名称通配符，表示请求的资源名称中只要包含指定的字符即可完成匹配。 例如，/some*.do表示的意思是，只要请求的资源名称以some开头即可；/*other.do表示的意思是，只要请求的资源名称以other结尾即可。 资源路径中使用通配符 在资源路径中使用通配符，有两种用法：路径级数的精确匹配，与路径级数的可变匹配。 /xxx/*/show.do：表示在 show.do 的资源名称前面，只能有两级路径，第一级必须是/xxx，而第二级随意。这种称为路径级数的精确匹配。 /xxx/**/show.do：表示在 show.do 的资源名称前面，必须以/xxx 路径开头，而其它级的路径是否包含，若包含又包含几级，各级又叫什么名称，均随意。这种称为路径级数的可变匹配。 对请求提交方式的定义对于@RequestMapping，其有一个属性 method，用于对被注解方法所处理请求的提交方式进行限制，即只有满足该 method 属性指定的提交方式的请求，才会执行该被注解方法。Method 属性的取值为 RequestMethod 枚举常量。常用的为 RequestMethod.GET 与RequestMethod.POST，分别表示提交方式的匹配规则为 GET 与 POST 提交。只要指定了处理器方法匹配的请求提交方式为 POST，则相当于指定了请求发送的方式：要么使用表单请求，要么使用 AJAX 请求。其它请求方式被禁用。当然，若不指定 method 属性，则无论是 GET 还是 POST 提交方式，均可匹配。即对于请求的提交方式无要求。 对请求中携带参数的定义@RequestMapping中 params 属性中定义了请求中携带的参数要求。 处理器方法的参数 处理器方法可以包含以下五类参数：HttpServletRequest、HttpServletResponse、HttpSession、用于承载数据的 Model、请求中所携带的请求参数。这些参数会在系统调用时由系统自动赋值，即程序员可在方法内直接使用。 这里只举例讲解一下第五类参数：请求中所携带的请求参数。即处理器方法是如何接收请求参数的。 逐个参数接收只要保证请求参数名与该请求处理方法的参数名相同即可。 校正请求参数名 --@RequestParam所谓校正请求参数名，是指若请求 URL 所携带的参数名称与处理方法中指定的参数名不相同时，则需在处理方法参数前，添加一个注解@RequestParam(“请求参数名”)，指定请求 URL 所携带参数的名称。 整体参数接收将处理器方法的参数定义为一个对象，只要保证请求参数名与这个对象的属性同名即可。参数名称中不用写为“对象.属性”的形式。 域属性参数的接收所谓域属性，即对象属性。当请求参数中的数据为某类对象域属性的属性值时，要求请求参数名为“域属性名.属性”。 请求URI中携带变量的接收 对于处理器方法中所接收的请求参数，可以来自于请求中所携带的参数，也可以来自于请求的 URI 中所携带的变量，即路径变量。此时，需要借助@PathVariable 注解。 @PathVariable 在不指定参数的情况下，默认其参数名，即路径变量名与用于接收其值的属性名相同。若路径变量名与用于接收其值的属性名不同，则@PathVariable 可通过参数指出路径变量名称。 处理器方法的返回值返回ModelAndView若处理器方法处理完后，需要跳转到其它资源，且又要在跳转的资源间传递数据，此时处理器方法返回 ModelAndView 比较好。 返回String返回内部资源逻辑视图名若要跳转的资源为内部资源，则视图解析器可以使用 InternalResourceViewResolver 内部资源视图解析器。此时处理器方法返回的字符串就是要跳转页面的文件名去掉文件扩展名后的部分。这个字符串与视图解析器中的 prefix、suffix 相结合，即可形成要访问的 URI。 当然，也可以直接返回资源的物理视图名。不过，此时就不需要再在视图解析器中再配置前辍与后辍了。 返回 View 对象名若要跳转的资源为外部资源，则视图解析器可以使用 BeanNameViewResolver，然后在配置文件中再定义一些外部资源视图 View 对象，此时处理器方法返回的字符串就是要跳转资源视图 View 的名称。当然，这些视图 View 对象，可以是内部资源视图 View 对象。 返回void通过 ServletAPI 传递数据并完成跳转通过在处理器方法的参数中放入 ServletAPI 参数，来完成资源跳转时所要传递的数据及跳转。一方面，可在方法参数中放入 HttpServletRequest 或 HttpSession，使方法中可以直接将数据放入到 request、session 的域中，也可通过 request.getServletContext()获取到ServletContext，从而将数据放入到 application 的域中。另一方面，可在方法参数中放入 HttpServletRequest 与 HttpServletResponse，使方法可以完成请求转发与重定向。 AJAX响应若处理器对请求处理后，无需跳转到其它任何资源，此时可以让处理器方法返回 void。例如，对于 AJAX 的异步请求的响应。处理器对于 AJAX 请求中所提交的参数，可以使用逐个接收的方式，也可以以对象的方式整体接收。只要保证 AJAX 请求参数与接收的对象类型属性同名。 返回Object 处理器方法也可以返回 Object 对象。但返回的这个 Object 对象不是作为逻辑视图出现的，而是作为直接在页面显示的数据出现的。 返回 Object 对象，需要使用@ResponseBody 注解，将转换后的 JSON 数据放入到响应体中。 返回数值型对象 返回字符串对象若要返回非中文字符串，将前面返回数值型数据的返回值直接修改为字符串即可。但若返 回的字符串中带有中文字符 ，需要使用@RequestMapping 的 produces 属性指定字符集。 返回自定义类型对象返回自定义类型对象时，不能以对象的形式直接返回给客户端浏览器，而是将对象转换为 JSON 格式的数据发送给浏览器的。 返回 Map 集合 返回 List 集合","categories":[{"name":"后端技术","slug":"后端技术","permalink":"http://jameszhan.cf/categories/后端技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jameszhan.cf/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"http://jameszhan.cf/tags/SSM/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://jameszhan.cf/tags/SpringMVC/"}]},{"title":"SSM学习系列（二）：SpringMVC概述","slug":"SSM学习系列（二）：SpringMVC概述","date":"2019-01-23T14:20:50.000Z","updated":"2019-01-24T03:11:33.249Z","comments":true,"path":"2019/01/23/SSM学习系列（二）：SpringMVC概述/","link":"","permalink":"http://jameszhan.cf/2019/01/23/SSM学习系列（二）：SpringMVC概述/","excerpt":"","text":"SpringMVC简介 SpringMVC属于表现层的框架，它是Spring框架的一部分。 SpringMVC实现过程详解 浏览器提交请求到中央调度器 中央调度器直接将请求转给处理器映射器。 处理器映射器会根据请求，找到处理该请求的处理器，并将其封装为处理器执行链后返回给中央调度器。 中央调度器根据处理器执行链中的处理器，找到能够执行该处理器的处理器适配器。 处理器适配器调用执行处理器。 处理器将处理结果及要跳转的视图封装到一个对象ModelAndView中，并将其返回给 处理器适配器。 处理器适配器直接将结果返回给中央调度器。 中央调度器调用视图解析器，将ModelAndView中的视图名称封装为视图对象。 SpringMVC开发流程导入Jar包注册中央调度器在web.xml配置文件中注册中央调度器 创建SpringMVC配置文件 定义处理器ModelAndView类中的addObject()方法用于向其Model中添加数据，因为该函数的返回值为ModelAndView，所以可以向Model中连续添加多个数据。 注册处理器在springmvc.xml中注册处理器。需要注意的是处理器的id属性值为一个请求URI，表示当客户端提交该请求时，会访问class指定的这个处理器。 配置试图解析器在springmvc.xml文件中配置视图解析器，是为了避免对于请求资源路径与扩展名的冗余，在视图解析器InternalResouceViewResolver中引入了请求的前缀和后缀。 定义目标页面编写前端页面代码 由以上步骤可以发现，程序员只需要开发处理器和视图，其他部分不用开发采用默认的即可。 URL路径问题访问路径与资源路径 通常的URL资源访问路径由两部分构成：访问路径与资源名称。 访问路径，则是通过该路径则可以定位到指定的资源，即在URL资源访问路径中除了资 源名称以外的其它部分。一般情况下，在URL访问路径中，最后一部分为资源名称，而其它部分则为访问路径。 资源名称指的是要访问资源的直接名称，如show.jsp，或与要访问资源存在映射关系的间接名称，如show.do。 绝对路径与相对路径 根据“访问路径是否可以独立完成资源准确定位”的评判标准，可以将访问路径分为绝对路径和相对路径。 绝对路径 绝对路径是指根据给出的访问路径可以准确定位到资源的路径，对于计算机中Web应用的绝对路径则是指带访问协议的路径。如：http://127.0.0.1:8080/primary/index.jsp 相对路径 相对路径是指根据给出的访问路径无法准确定位到资源的路径，相对路径必须要结合其参照路径才可以组成可以准确定位资源的绝对路径。 在Web应用中，相对路径的写法有两种：一种是以斜杠开头的相对路径，一种是不以 斜杠开头的相对路径。根据相对路径是否以斜杠开头，且出现的文件所处位置的不同，其默认的参照路径是不同的，这也是相对路径容易出错的地方：确定参照路径！ 以斜杠开头的相对路径前台路径所谓前台路径是指，由浏览器解析执行的代码中所包含的路径。例如，html、css、js中的路径，及jsp中静态部分的路径。像html及jsp中的静态部分中的img src=” “、href=” “、form action=” “等；像 css 中的 background:img(“ “}等；像 window.location.href=” “，都属于前台路径。前台路径的参照路径是Web服务器的根路径，即：http://127.0.0.1:8080/ 后台路径所谓后台路径是指，由服务器解析执行的代码及文件中所包含的路径。例如，java代码中的路径、jsp文件动态部分（java代码块）中的路径、xml文件中的路径（xml文件是要被 java代码加载入内存，并由java代码解析的）等。后台路径的参照路径是Web应用的根路径。如：http://127.0.0.1:8080/primary/ 后台路径特例对于后台路径的参照路径有一个特例：当代码中使用 response 的 sendRedirect()方法进行重定向时，其参照路径不是web应用的路径，而是web服务器的根路径。例如，执行response.sendRedirect(“/show.jsp”)将会报404错误。因为其参照路径是 Tomcat的根，而非当前项目的根。所以若要使用重定向，要么写为无斜杠的相对路径，要么在路径上添加项目名称。 不以斜杠开头的相对路径不以斜杠开头的相对路径，无论是前台路径，还是后台路径，其参照路径都是当前资源的访问路径，而不是当前资源的保存路径。","categories":[{"name":"后端技术","slug":"后端技术","permalink":"http://jameszhan.cf/categories/后端技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jameszhan.cf/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"http://jameszhan.cf/tags/SSM/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://jameszhan.cf/tags/SpringMVC/"}]},{"title":"SSM学习系列（一）：前言","slug":"SSM学习系列（一）：前言","date":"2019-01-22T10:58:40.000Z","updated":"2019-01-23T14:41:22.132Z","comments":true,"path":"2019/01/22/SSM学习系列（一）：前言/","link":"","permalink":"http://jameszhan.cf/2019/01/22/SSM学习系列（一）：前言/","excerpt":"","text":"SSM是Spring、SpringMVC、Mybatis的简称，是现在常用的java web开发框架之一。本学习系列是笔者在学习北京动力节点教学资料后的笔记与总结。 第一讲前言，主要内容概括起来就是一种系统架构，两个常用工具，三例设计模式。 系统架构 Java Web都遵循三层架构原则；三层架构中的视图层使用MVC结构；Spring是管理和实现三层架构的一种技术框架；SpringMVC是一种实现视图层的特殊MVC；MyBatis是一种实现持久层的方式。 Java三层架构 MVC 三层架构与MVC SSM与三层架构 JUint测试 JUnit测试是一种方便且高效的测试工具。 完成测试的步骤 下载Jar包并在工程中导入。 创建测试类：有两种方式，一种是使用IDE向导自动创建；一种是使用注解手动创建。 使用@Before @After @Test注解，编写相应函数 Log4j日志 Log4j与Log4j2是Apache公司开发的日志记录工具。日志信息根据用途与记录内容的不同，分为调试日志、运行日志、异常日志等，日志记录对软件的开发十分有用。 日志级别分为：fatal、error、warn、info、debug、trace 日志输出控制文件的主要构成：输出位置、输出级别、输出格式 完成日志记录的步骤 导入Jar包 放入日志输出控制文件 代码中实现日志记录：在需要输出日志的类中创建日志对象logger，并通过logger的方法在代码中加入日志输出语句。如：logger.debug(“this is debug message”) 代理模式 代理模式的出现是因为某些情况下一个对象不适合或不能被另一个对象引用 ，于是会提供一种代理以控制对对象的访问，就好比打官司的时候，当事人会请代理律师。即代理就是委托其他类做自己不擅长或者不想直接参与的事情。 律师分为法律顾问和普通律师，代理也分为静态代理和动态代理，区别就在于代理关系建立的时间。 静态代理 即法律顾问，在官司产生前，即程序运行前便确定好的。需要自己定义代理类，并要与目标类实现相同的业务接口。 动态代理 即普通律师，在官司产生后，即在程序运行时确定的。 JDK动态代理通过java.lang.reflect.Proxy类实现代理，使用其newProxyInstance()方法。主业务逻辑增强类需要实现接口InvocationHandler，并且重写invoke()方法，增强逻辑的代码就写在该方法中。使用JDK的Proxy实现代理，要求目标类与代理类实现相同的接口。若目标类不存在接口，则无法使用该方式实现。 CGLIB动态代理对于无接口的目标类，就需要使用CGLIB实现，但条件是目标类必须能被继承，不能是final类。通过代理生成工厂类实现，该类需要实现MethodInterceptor接口。在类中需要做三件事：（1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。（2）定义代理的生成方法，用来创建代理对象，其中需要创建一个增强器Enhancer并设置回调setCallBack()。（3）定义回调接口方法，对目标类的增强就在这里完成。 适配器模式 适配器模式就是某些类的接口转换为可以统一管理的接口.目的在于使没有办法一起工作的类一起工作，方便管理。类比于将不同工作的人统一组织起来，一起工作，便于统一管理。 不使用适配器调用各个类时，只能分别调用。 单适配器模式只有一个适配器接口，当调用类时，需要用适配器接口进行匹配。 多适配器模式用总的适配器接口去匹配各个类的适配器，实现统一管理。 缺省适配器模式当Targer目标角色有很多方法，那么每个适配器都要去实现接口中这些方法，这样做太麻烦。于是可以首先实现一个默认适配器，然后实际的实现目标角色接口类去继承这个默认适配器，然后重写默认实现的方法即可。 模板方法设计模式 某些类的实现可能会需要几个固定步骤。而对于该类的不同对象，有些步骤的实现是固定不变的，有些是完全不同的，有些是可变可不变的，于是就会用到模板方法设计模式。节省代码量。 好比在完成网络购物的时候，登录是每个用户都必须要做的，选择物品是每个用户都不一样的，选择付款时只有固定的几种，默认支付宝，但也可以使用银行卡支付。这便是模板方法设计模式。 模板方法的构成 模板方法的实现一个父类，包含模板方法和步骤方法；若干子类，继承父类，并重写抽象方法和选择性重写钩子方法。","categories":[{"name":"后端技术","slug":"后端技术","permalink":"http://jameszhan.cf/categories/后端技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jameszhan.cf/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"http://jameszhan.cf/tags/SSM/"}]},{"title":"Java web架构介绍","slug":"Java-web架构介绍","date":"2019-01-21T13:40:57.000Z","updated":"2019-01-23T14:42:00.832Z","comments":true,"path":"2019/01/21/Java-web架构介绍/","link":"","permalink":"http://jameszhan.cf/2019/01/21/Java-web架构介绍/","excerpt":"","text":"常规的J2EE三层架构 Alibaba提倡的分层结构 Web 层主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 Service 层相对具体的业务逻辑服务层。 Manager 层通用业务处理层，它有如下特征： 1） 对第三方平台封装的层，预处理返回结果及转化异常信息； 2） 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理； 3） 与 DAO 层交互，对多个 DAO 的组合复用。 DAO 层数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。 开放接口层可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。 终端显示层各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。 外部接口或第三方平台包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。 MVC的结构 SpringMVC的结构及工作原理 工作流程详解 客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。 DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。 在这个地方Spring会通过HandlerAdapter对该处理进行封装。 HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。 Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。 ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。 当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。 客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。 组件及其作用 前端控制器 (DispatcherServlet)接收请求，响应结果，相当于转发器，中央处理器。负责调用系统的其他模块来真正处理用户的请求。 有了DispatcherServlet减少了其他组件之间的耦合度 处理器映射器 (HandlerMapping)作用：根据请求的 url 查找 Handler 处理器 (Handler)注意：编写 Handler 时按照 HandlerAdapter 的要求去做，这样适配器才可以去正确执行 Handler处理器适配器 (HandlerAdapter)作用：按照特定规则（HandlerAdapter要求的规则）执行Handler。 视图解析器 (ViewResolver)作用：进行视图解析，根据逻辑视图解析成真正的视图 (View) 视图 (View)View 是一个接口实现类支持不同的 View 类型（jsp,pdf等等） 进行SpringMVC开发时，程序员只需编写处理器和视图。","categories":[{"name":"后端技术","slug":"后端技术","permalink":"http://jameszhan.cf/categories/后端技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://jameszhan.cf/tags/Java/"},{"name":"web","slug":"web","permalink":"http://jameszhan.cf/tags/web/"}]},{"title":"Markdown学习笔记","slug":"Markdown学习笔记","date":"2019-01-21T03:43:51.000Z","updated":"2019-01-21T13:27:43.577Z","comments":true,"path":"2019/01/21/Markdown学习笔记/","link":"","permalink":"http://jameszhan.cf/2019/01/21/Markdown学习笔记/","excerpt":"","text":"今天大概学习了一下Markdown的语法，感觉也不是那么难，用起来都比较方便。作为一门编辑类工具，相信是越用越熟，以后多多练习，必能熟练掌握。 那么就先简单介绍一些常用的语法，之后有需求再去更新。 标题标题有以下六种 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 文字格式强调**这是文字粗体格式** *这是文字斜体格式* &lt;del&gt;在文字上添加删除线 或 ~~在文字上添加删除线~~ `在文字下增加底纹` 这是文字粗体格式 这是文字斜体格式 在文字上添加删除线或在文字上添加删除线 在文字下增加底纹 自定义字体、字号和颜色&lt;font color=#0099ff size=6 face=&quot;黑体&quot;&gt;颜色，字号，字体&lt;/font&gt; 颜色，字号，字体 链接[文本内容]（链接地址） 百度一下 图片原始版此种方式无法改变图片的大小 ![图片的描述](图片的链接地址) 最爱的詹姆斯 升级版此种方式可自定义图片大小 &lt;img src=&quot;./xxx.png&quot; width = &quot;300&quot; height = &quot;200&quot; alt=&quot;图片名称&quot;/&gt; 如果需要居中的话只要在语句外面包围div标签即可 &lt;div align=&quot;center&quot;&gt; ... &lt;/div&gt; 引用在文本内容之前加上 &gt;（大于号），即可将文本变成引用文本 &gt;这是引用部分 这是引用部分 代码框前面用到了很多代码框，即每个大框都是代码框。有两种办法：1.一对“上三点”包裹代码 2.代码前加四个空格（一个tab键）。两种语法的显示在不同编辑器下可能会有些许区别，前者会有标号。 123public void test()&#123; System.out.println(&quot;这就是代码框&quot;)&#125; public void test(){ System.out.println(&quot;这就是代码框&quot;) } 水平分割线前面也用到了许多分割线，三个小短线即可表示。 --- 就是这小三只 列表列表项目标记通常放在最左边，项目标记后面要接一个字符的空格 无序列表使用星号、加号或是减号作为列表标记 - 第一 - 第二 - 第三 第一 第二 第三 有序列表使用数字接着一个英文句点 1. Red 2. Green 3. Blue Red Green Blue 待办列表表示列表是否勾选状态（注意：[ ] 前后都要有空格） - [ ] 不勾选 - [x] 勾选 不勾选 勾选","categories":[{"name":"语言语法","slug":"语言语法","permalink":"http://jameszhan.cf/categories/语言语法/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://jameszhan.cf/tags/Markdown/"}]},{"title":"个人博客处女作","slug":"个人博客处女作","date":"2019-01-19T11:14:40.000Z","updated":"2019-01-19T15:17:44.478Z","comments":true,"path":"2019/01/19/个人博客处女作/","link":"","permalink":"http://jameszhan.cf/2019/01/19/个人博客处女作/","excerpt":"","text":"千呼万唤始出来，james的个人博客终于开通啦！！！ 首先，感谢师兄陈坤大佬的鼎力相助，本博客是完全按照师兄的教程来搭建的，顺便安利一下师兄的个人博客。 接下来说一下自己的几点想法。 为什么会想着开通个人博客说实话，最初想着开个人博客就是单纯地觉得有博客是一个挺牛逼的事，毕竟大佬们都是一有github，二有个人博客，三有微信公众号。正所谓不想当大佬的渣渣不是优秀工程师嘛。 之后也在CSDN也写过一些技术文章，写着写着就觉得比较局限。首先吧，CSDN的博客页面不是很美丽，影响阅读体验；其次呢，写博客的时候是在它的在线markdown编辑器下进行，用起来不太顺手，而且图片还有水印，让人难以接受；最最重要的是，CSDN它有广告啊，就很烦这一点，明明是单纯的技术分享，阅读的同时页面右侧还有广告随着你的页面移动，令人抓狂。 前不久恰逢听闻陈坤师兄用极其简单且免费的方法搭建了自己的个人博客，立马就动心了，还没考完《矩阵论》，心里就开始琢磨自己该整一个什么样的。本来以为个人博客得放在自己的服务器上，需要部署还得更新上传，没想到hexo+github如此简单，年轻人要学的还有很多啊！ 还有markdown,自己用的不多，借着个人博客的开通，希望自己能坚持写作，日后慢慢熟悉。 打算在博客写什么 技术文章。 研究生期间需要自学的东西很多，很多时候学完了如果没有用到的话很快就会遗忘，等某一天需要的时候又得重新学习，所以记录自己的所学很重要。后期我会将CSDN的文章迁移过来。 项目总结。 每一次所做的项目，我想都有必要去好好回顾与总结。一方面是对所做项目所花时间有个交代，另外也是对未来的工作有一定的指导意义。 随笔。 目前自己的总结和心里记录都是写在自己的有道云笔记里，以后可以考虑迁移到个人博客中来。其次，对于一些社会热点事件，个人小思绪，我也会写在博客中。 自从詹姆斯加盟湖人，紫金便是我最爱的配色。观感尚可，希望大家能多提建议！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://jameszhan.cf/tags/随笔/"}]}]}